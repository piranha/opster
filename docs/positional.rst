.. -*- mode: rst -*-

======================
 Positional Arguments
======================

.. hidden::

    $  # Allow opster directory to be overridden
    >  if [ -z "$OPSTER_DIR" ]; then
    >    OPSTER_DIR="$TESTDIR/.."
    >  fi

    $  # Add current dev version of opster to PYTHONPATH
    >  export PYTHONPATH="$OPSTER_DIR"

    $  # Change into the docs/scripts directory to run the tests
    >  cd "${OPSTER_DIR}/docs/scripts"

    $  # Add the 2to3 built version of opster.py to PYTHONPATH when running
    >  # Python 3.x scripts
    >  PYTHON3=`which python3`
    >  python3() {
    >     PYTHONPATH="${OPSTER_DIR}/build/lib" "${PYTHON3}" $*
    >  }

A simple example
================

Before considering how Opster handles positional arguments it is instructive
to look at a simple example of a script that does not use opster. Opster works
by turning a function into a script. The simplest way to construct a script
that receives some positional command line arguments and sends them to a
function looks something like `basic.py`:

.. literalinclude:: scripts/basic.py

This script has one required argument, ``arg1``, and one optional argument,
``arg2``, (defaulting to ``None``). With valid arguments everything is fine::

    $ python basic.py spam
    arg1: spam
    arg2: None

    $ python basic.py spam ham
    arg1: spam
    arg2: ham

However `basic.py` does not fail gracefully when given too many or too few
input arguments::

    $ python basic.py spam ham eggs
    Traceback (most recent call last):
      File "basic.py", line 13, in <module>
        main(*sys.argv[1:])
    TypeError: main() takes at most 2 arguments (3 given)
    [1]

Using opster
============

Using Opster we can make a friendlier script, `better.py`, with only a handful
of changes:

.. literalinclude:: scripts/better.py
  :emphasize-lines: 5, 7, 9, 14

Let us briefly consider the changes highlighted above:

#. We need to import opster's ``command`` decorator.
#. ``@command()`` is used to decorate the ``main`` function.
#. The doc-string for ``main`` is changed to a message suitable for a
   command-line user.
#. Instead of calling ``main`` directly we call its ``.command`` attribute
   (which was added by the ``@command()`` decorator).

So what happens when we run this script from the command line? For valid
arguments nothing changes::

    $ python better.py spam
    arg1: spam
    arg2: None

    $ python better.py spam ham
    arg1: spam
    arg2: ham

However `better.py` can now print helpful output when run ``-h`` or
``--help``::

    $ python better.py --help
    better.py ARG1 [ARG2]
    
    Display the values of ARG1 and ARG2
    
    options:
    
     -h --help  display help

If `better.py` is given the wrong number of arguments it will say so and then
print out its help message. This is the more typical behaviour that users
expect when they type the wrong arguments to a command line program::

    $ python better.py spam ham eggs
    better.py: invalid arguments
    
    better.py ARG1 [ARG2]
    
    Display the values of ARG1 and ARG2
    
    options:
    
     -h --help  display help

How it works
============

The idea of Opster is to quickly turn a python function into a full-featured
command line script. Opster decides how to do this by looking at the arguments
of the function that is wrapped with ``command`` decorator. Let us consider a
slightly more complicated example `complete.py`:

.. literalinclude:: scripts/complete.py

The ``main`` function in `complete.py` has two required arguments and four
optional arguments. Opster interprets the two required arguments to ``main``
as required positional arguments for the the script. For each optional
argument to ``main`` Opster checks the type of the default value: if it is a
`tuple` it is assumed to be the definition of an `option`. Otherwise the
optional arguments to ``main`` are taken to be optional `positional` arguments
to the script. We can check the help output from this script::

    $ python complete.py --help
    complete.py [OPTIONS] INFILE OUTFILE [PATTERN] [EXCLUDE]
    
    Write lines from INFILE to OUTFILE.
    
        If PATTERN and/or EXCLUDE is given,
        only lines matching PATTERN but not
        matching EXCLUDE will be written
    
    options:
    
     -r --regex     Use regular expressions
     -e --extended  Use extended syntax
     -h --help      display help

The above help message is generated by combining three things:

#. The usage string for the script. This was generated by Opster from the name
   of the script and the capitalised names of the arguments to the ``main``
   function.
#. The docstring for the ``main`` function is displayed as an explanation of
   what the script does.
#. The list of option arguments that the script takes (The ``help`` option was
   added automatically by Opster).

Since `complete.py` has two required arguments (``INFILE`` and ``OUTFILE``) and
two optional positional arguments (``PATTERN`` and ``EXCLUDE``) it can take
between two and four positional arguments and will give an error message
otherwise. If either of the optional positional arguments is not given, the
corresponding argument to ``main`` will be set to its default value as given
in the definition of ``main``::

    $ python complete.py brian.txt judea.txt
    infile: brian.txt
    outfile: judea.txt
    pattern: .*
    exclude: None

    $ python complete.py brian.txt judea.txt messiah "naughty boy"
    infile: brian.txt
    outfile: judea.txt
    pattern: messiah
    exclude: naughty boy

The ``command`` decorator wraps the ``main`` function, but ensures that it can
still be called as a function from within python. This is useful if you want
to import the function in another module and use it there:

.. doctest::

  >>> from scripts.complete import main
  >>> main('brian.txt', 'judea.txt')
  infile: brian.txt
  outfile: judea.txt
  pattern: .*
  exclude: None

Keyword-only arguments: the new syntax
======================================

Python 3 introduced the ability to define arguments to a Python function
that are explicitly `keyword-only` in the function signature. This enables a
clear separation between `positional` arguments and `option` arguments that
the ``command`` decorator can use when inspecting a function. Scripts that are
only intended to run under Python 3 should use keyword-only arguments to
define options as shown in `kwonly.py`:

.. literalinclude:: scripts/kwonly.py
  :language: python3
  :emphasize-lines: 10

This script would be a syntax error on Python 2 but works as you would expect
on Python 3::

    $ python3 kwonly.py --help
    kwonly.py [OPTIONS] ARG1 [ARG2]
    
    spam the ham
    
    options:
    
     -e --eggs  use eggs
     -h --help  display help

If ``main`` has any keyword-only arguments then the ``command`` decorator will
assume that all `keyword-only` arguments are `option` definitions and that all
positional arguments to ``main`` are positional arguments to the script. This
means that Opster will not check the type of the default value to see if it is
a tuple and it is possible to have a positional argument whose default value
is a tuple, such as ``arg2`` in `kwonly.py`::

    $ python3 kwonly.py foo
    arg1: foo
    arg2: ()
    eggs: False

While Opster supports Python 2.6 and 2.7 it will need to support the syntax
that does not use `keyword-only` arguments to define options. It is
recommended that any scripts running only under Python 3.x should use the new
syntax.

Accepting a variable number of arguments
========================================

Many command line applications can accept an unlimited number of command line
arguments. Opster provides support for this using Python's `varargs` syntax.
If we can use `keyword-only` arguments for option definitions, then we can
simply place the `varargs` paramerer at the end of the list of positional
arguments like in `varargs.py`:

.. literalinclude:: scripts/varargs.py
  :language: python3

The usage string illustrates the fact that many values can be provided with an
ellipsis ``...`` after ``CHEESES``::

    $ python3 varargs.py --help
    varargs.py [OPTIONS] SHOP [CHEESES ...]
    
    Buy cheese
    
    options:
    
     -m --music  provide musical accompaniment
     -h --help   display help

The parameter ``cheeses`` will receive a tuple of any command line arguments
supplied after the required ``SHOP`` argument. This is the same behaviour that
we would expect if the function was called from Python (without any keyword
agruments)::

    $ python3 varargs.py wensleydale cheddar ilchester camembert
    shop: wensleydale
    cheeses: ('cheddar', 'ilchester', 'camembert')

Because the `keyword-only` syntax is unavailable on Python 2.x, Opster
provides an alternative syntax for specifying that a script should accept a
variable number of arguments, which is to place the `varargs` parameter
at the end of the argument list `after` the option definitions as shown in
``varargs_py2.py``:

.. literalinclude:: scripts/varargs_py2.py

Opster will take care of ensuring that the ``cheeses`` parameter in the
``main`` function of `varargs_py2.py` still receives the positional command
line arguments the same way as in `varargs.py`::

    $ python varargs_py2.py wensleydale cheddar ilchester camembert
    shop: wensleydale
    cheeses: ('cheddar', 'ilchester', 'camembert')

Opster also ensures that all positional arguments after the first are passed
to ``cheeses`` when ``main`` is called directly (this would not have been the
case if ``main`` was not wrapped by ``@command()``):

.. doctest::

  >>> from scripts.varargs_py2 import main
  >>> main('wensleydale', 'cheddar', 'ilchester', 'camembert')
  shop: wensleydale
  cheeses: ('cheddar', 'ilchester', 'camembert')

